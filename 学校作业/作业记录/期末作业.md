> 本次实验所有代码已更新到 [个人 GitHub](https://github.com/xingwenzan/CProgramFiles/tree/master/%E5%AD%A6%E6%A0%A1%E4%BD%9C%E4%B8%9A/%E5%AE%9E%E9%AA%8C%E4%B8%80)

## 目录

- [[#目录]]
- [[#任务要求]]
- [[#任务实现]]
	- [[#提前声明]]
	- [[#版本 1.0]]
	- [[#版本 1.1]]
	- [[#版本 2.0]]
	- [[#版本 1.2]]
	- [[#版本 1.3]]
	- [[#附录]]

## 任务要求

### 基础要求

该程序是一个24点的扑克牌游戏，玩家与庄家（计算机）依次要牌，玩家和庄家最多可以各要5张牌，如果牌的点数超过24，则为爆牌，自动出局；在不超过24点的情况下，玩家与庄家（计算机）比较牌点数的大小，大者为赢。程序中一共有13张扑克牌可以随机抽取，大于10的点数为10。

### 进阶要求（附加题）

- 增添游戏界面，使其界面美观整洁，并在游戏前说明规则。
- 添加赌注功能，要求为起始资金为100 点，每次要牌可以设定押金，即如果开始下的是10点的注，如果赢得游戏，则赢取双倍押金，即下注 10 点，赢得游戏则获得 20 点。当然，押金不能超过你所有的总钱数。
- VIP 功能，要求为可以查看可以查看下一张牌，即按 D 键，然后要求输入密码，密码正确可以看牌，并决定是否要牌。当然，在游戏规则上不能泄露这个秘密。
- 其他功能，使得整个程序有趣。

## 任务实现

### 提前声明

> 对勾划线部分代表该版本实现该功能或该版本是否解决该问题，例如：

- [x] 代表 `该功能在该版本已经实现` 或 `该问题已解决` 
- [ ] 代表 `该功能在该版本未实现` 或 `该问题未解决` 

> 版本之间的更新可能改动较大，这是由于创作者本人 `面向对象` 不完全，考虑不周所导致

> 后版本理论上会包含前置版本的所有已有功能，但未必不会存在特殊情况，且本文纯粹按照创作者个人的思路记录，前置版本功能比后版本功能少很正常

> 时间充裕的情况下，创作者会尽可能补充当时编程的思路（ ~~不保证一定会写~~ ）

> 受 markdown 软件限制，本文部分代码会莫名其妙换行（其实是原本一行里代码太长了，单行放不下，自动换行显示，其实还是在一行），导致部分代码不能完全复制粘贴使用，纯属正常现象，本人会尽可能规避

### 版本 1.0

[[#目录]]（回到目录）

> 版本功能

- [x] 基础游玩（抽牌、爆牌、胜利、开牌）
- [x] PVP
- [x] PVE
- [ ] 窗口/看板
- [ ] UI（牌、人）
- [x] 多种牌库（13 牌基础版、54 牌完全版、自定义牌库，且可通过代码直接添加）
- [x] 赌注模式（自定义次数循环赌注、非赌注正常模式）
- [ ] VIP 功能
- [ ] 牌特殊功能
- [x] 排名查看

> 存在问题

- [ ] 随机数不随机
- [ ] 无 UI，只能通过 Code Editor 区域输入输出
- [ ] 玩家之间可以看到其他人的牌（人看其他人、人看电脑）
- [ ] 为简化代码，一般模式下 JQK 直接设置成了 10，规则适应不完全（只能设置代表该大小的牌多少张，不能设置对应牌面；一些牌的特殊功能也不能实现）

> 版本代码

```C
//  
// Created by 86159 on 2023-06-05.  
//  
#include "stdio.h"  
#include "stdlib.h"  
  
typedef struct {  
    int mode;   //游玩模式  
    int cards[15];   // 存各数字牌剩余数量  
} Deck;   // 牌库结构体  
  
typedef struct {  
    int idx;   // 玩家编号  
    int cards[5];   // 手牌  
    int cardNum;   // 几张牌  
    int sum;   // 总和  
    int computer;   // 是否电脑  
    float money;   // 赌资  
    int vip;   // 是否 VIP - 暂未实现使用，仅有该属性  
} Player;   // 玩家结构体  
  
int decks[3][15] = {  
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0},  
        {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 0},  
        {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1}  
};  
  
  
// 玩家初始化  
Player playerInit(Player player) {  
    player.sum = 0;  
    player.cardNum = 0;  
    return player;  
}  
  
  
// 快速排序 - 按牌面  
void quickSortSum(Player players[], int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1, x = players[(l + r + 1) >> 1].sum;  
    while (i < j) {  
        do {  
            i++;  
        } while (players[i].sum > x);  
        do {  
            j--;  
        } while (players[j].sum < x);  
        if (i < j) {  
            Player tmp = players[i];  
            players[i] = players[j];  
            players[j] = tmp;  
        }  
    }  
    quickSortSum(players, l, i - 1);  
    quickSortSum(players, i, r);  
}  
  
  
// 快速排序 - 按赌资  
void quickSortMoney(Player players[], int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1;  
    float x = players[(l + r + 1) >> 1].money;  
    while (i < j) {  
        do {  
            i++;  
        } while (players[i].money > x);  
        do {  
            j--;  
        } while (players[j].money < x);  
        if (i < j) {  
            Player tmp = players[i];  
            players[i] = players[j];  
            players[j] = tmp;  
        }  
    }  
    quickSortMoney(players, l, i - 1);  
    quickSortMoney(players, i, r);  
}  
  
  
// 输入玩家数组、游玩人数，得到胜利者 - 一般模式  
int getWinnerBase(Player players[], int num) {  
    quickSortSum(players, 0, num - 1);  
    for (int i = 0; i < num; ++i) {  
        if (players[i].sum <= 24) {  
            return players[i].idx;  
        }  
    }  
}  
  
  
//输入玩家数组、游玩人数，得到胜利者 - 赌注模式  
int getWinnerStake(Player players[], int num) {  
    quickSortMoney(players, 0, num - 1);  
    return players[0].idx;  
}  
  
  
// 牌库模式选择  
Deck deckModeChoose(Deck deck) {  
    int mode;   // 牌库模式  
    printf("选择牌库模式：\n0、自定义牌组模式； 1、13 模式； 2、52 两王相等模式； 3、52 两王不等模式; \n");  
    scanf("%d", &mode);  
    // 牌库放牌  
    if (mode) {  
        for (int i = 0; i < 15; ++i) {  
            deck.cards[i] = decks[deck.mode - 1][i];  
        }  
    } else {  
        int tmp;  
        for (int i = 0; i < 15; ++i) {  
            scanf("%d", &tmp);  
            deck.cards[i] = tmp;  
        }  
    }  
    return deck;  
}  
  
  
// 游玩过程 - 单次基础游玩  
int playBase(Player players[], Deck deck, int playerNum) {  
    int winner = -1, currentPlayer = 0, boom = 0;   // 胜利者、当前玩家、爆牌人数  
    deck = deckModeChoose(deck);   // 牌库模式选择  
//    for (int i = 0; i < 15; ++i) {  
//        printf("%d ", deck.cards[i]);  
//    }  
    // 初始化玩家  
    for (int i = 0; i < playerNum; ++i) {  
        printf("%d 号玩家：\n", i);  
        players[i] = playerInit(players[i]);  
    }  
    // 正式游戏  
    while (winner < 0) {  
        // 抽牌  
        int card = rand() % 15;  
        while (!deck.cards[card]) {  
            card = rand() % 15;  
        }  
        deck.cards[card]--;  
        card += 1;   // 由于牌面是 1-15，而储存是 0-14，故加一  
        printf("\n%d 号玩家得到牌 %d，", currentPlayer, card);  
  
        // 加牌  
        players[currentPlayer].cards[players[currentPlayer].cardNum++] = card;  
        players[currentPlayer].sum += card;  
        printf("%d 号玩家目前有 %d 张牌", currentPlayer, players[currentPlayer].cardNum);  
  
        // 情况判定：爆牌、自动胜利、是否开牌  
        if (players[currentPlayer].sum > 24) {  
            printf("\n%d 号玩家爆了", currentPlayer);  
            boom++;  
        } else if (players[currentPlayer].sum == 24) {  
            printf("\n%d 号玩家达到 24 点，自动胜利",currentPlayer);  
            winner = currentPlayer;  
        }  
  
        // 爆牌人数过多 某人直接胜利  
        if (boom >= playerNum - 1) {  
            winner = currentPlayer;  
        }  
  
        // 投票表决是否开牌：所有人牌数相同且大于等于 2 开启表决 -> 大于一半人同意则开牌  
        if (currentPlayer == playerNum - 1 &&players[currentPlayer].cardNum>=2) {  
            printf("\n请玩家选择是否开牌\n0、否；1、是");  
            int votes = 0, tmp;   // 票数 投票人同意与否  
            for (int i = 0; i < playerNum; ++i) {  
                if (players[i].sum > 24) { continue; }   // 爆牌者跳过  
                printf("\n%d 号玩家是否同意开牌\n", i);  
                if (players[i].computer) {   // 是电脑-随机表决  
                    tmp = rand() % 2;  
                } else {  
                    scanf("%d", &tmp);  
                }  
                votes += tmp;  
                printf("%d 号玩家选 %d", i, tmp);  
            }  
            if (votes > (playerNum - boom) / 2) {  
                printf("\n更多人同意开牌\n");  
                winner = getWinnerBase(players, playerNum);  
            } else {  
                printf("\n更多人不同意开牌\n");  
            }  
        }  
  
        // 下一个人  
        currentPlayer = (currentPlayer + 1) % playerNum;  
        while (players[currentPlayer].sum > 24) {  
            currentPlayer = (currentPlayer + 1) % playerNum;  
        }  
    }  
    return winner;  
}  
  
  
// 游玩过程 - 赌注模式  
int playStake(Player players[], Deck deck, int playerNum, int freq) {  
    float stakes[playerNum];  
    while (freq--) {  
        for (int i = 0; i < playerNum; ++i) {  
            printf("请 %d 号玩家输入赌注\n", i);  
            scanf("%f", &stakes[i]);  
        }  
        int winner = playBase(players, deck, playerNum);  
        printf("\n本轮 %d 胜利\n\n", winner);  
        for (int i = 0; i < playerNum; ++i) {  
            if (i == winner) {  
                players[i].money += stakes[i] * (playerNum - 1);  
            } else {  
                players[i].money -= stakes[i];  
            }  
        }  
    }  
    return getWinnerStake(players, playerNum);  
}  
  
  
// 榜单输出  
void listOut(Player players[], Deck deck, int playerNum) {  
    printf("\n榜单如下：");  
    for (int i = 0; i < playerNum; ++i) {  
        if (deck.mode) {  
            printf("\n玩家编号 %d 总分 %d\n持有牌面", players[i].idx, players[i].sum);  
            for (int j = 0; j < players[i].cardNum; ++j) {  
                printf("%d ", players[i].cards[j]);  
            }  
        } else {  
            printf("\n玩家编号 %d 总分 %f\n持有牌面", players[i].idx, players[i].money);  
        }  
    }  
}  
  
  
// 主函数  
int main() {  
    int nextGame = 1;   // 是否进行下一局游戏；1-是，进行；0-否，不进行  
    while (nextGame) {  
        Deck deck;  
        int playerNum;   // 游玩人数  
  
        // 玩家定义  
        printf("输入游玩人数：\n");  
        scanf("%d", &playerNum);  
        Player players[playerNum];  
        for (int i = 0; i < playerNum; ++i) {  
            printf("\n%d 号玩家：\n", i);  
            players[i].idx = i;  
            players[i].money = 100;  
            printf("  该玩家是： 0、真人； 1、电脑；\n");  
            scanf("%d", &players[i].computer);  
            printf("  该玩家是否 VIP： 0、否； 1、是；\n");  
            scanf("%d", &players[i].vip);  
//            players[i] = playerInit(players[i]);  
        }  
        printf("玩家定义完成\n");  
  
        // 游玩模式选择  
        printf("选择游玩模式：\n0、赌注模式； 1、常规模式；\n");  
        scanf("%d", &deck.mode);  
        int freq;  
        if (!deck.mode) {  
            printf("赌注模式下游玩轮数\n");  
            scanf("%d", &freq);  
        }  
  
        // 输出榜单和胜利者  
        int winner = deck.mode ? playBase(players, deck, playerNum) : playStake(players, deck, playerNum, freq);  
        listOut(players, deck, playerNum);  
        printf("\n%d 号玩家胜利\n\n是否开启下一局\n0、否；1、是\n", winner);  
        scanf("%d", &nextGame);  
    }  
    return 0;  
}
```

### 版本 1.1

[[#目录]]（回到目录）

> 版本功能

- 老功能

- [x] 基础游玩（抽牌、爆牌、胜利、开牌）
- [x] PVP
- [x] PVE
- [ ] 窗口/看板
- [ ] UI（牌、人）
- [x] 多种牌库（13 牌基础版、54 牌完全版、自定义牌库，且可通过代码直接添加）
- [x] 赌注模式（自定义次数循环赌注、非赌注正常模式）
- [x] VIP 功能
- [x] 牌特殊功能（计分权重/逻辑等）
- [x] 排名查看

- 新提出功能

- [ ] 自主选择是否要牌
- [ ] 电脑也可以 VIP

> 存在问题

- 老问题

- [x] 随机数不随机
- [ ] 无 UI，只能通过 Code Editor 区域输入输出
- [ ] 玩家之间可以看到其他人的牌（人看其他人、人看电脑）
- [x] 为简化代码，一般模式下 JQK 直接设置成了 10，规则适应不完全（只能设置代表该大小的牌多少张，不能设置对应牌面；一些牌的特殊功能也不能实现）

- 新问题

- [ ] 仅 VIP 可选择要不要牌，非 VIP 不能选择，导致非 VIP 玩家达到一定点数后想不要只能想办法开牌，否则几轮后必然爆牌
- [ ] 赌注不设限

> 更新内容

- VIP 功能实现
- 解决随机数不随机
- 解决牌面展示
- 更新单轮游戏循环模式
- 添加特殊点数计算功能
- 取消至少每个人 2 张牌才可以开牌的限制

> 版本代码

```C
//  
// Created by 86159 on 2023-06-05.  
//  
#include "stdio.h"  
#include "stdlib.h"  
#include "time.h"  
  
  
/* 牌库结构体属性  
 * playMode 游玩模式  
 * cards[15] 存各数字牌剩余数量  
 * scoreMode 计分模式  
 * // 通过二进制编码代表模式开关，0 关/否 1 开/是  
 * // 从低到高：自定义权重、不同牌不同权重、大于 10 变 10、A 可代表 1 或 11 * weight[15] 各牌权重  
 */
 typedef struct {  
    int playMode;  
    int cards[15];  
    int scoreMode;  
    float weight[15];  
} Deck;  
  
typedef struct {  
    int idx;   // 玩家编号  
    int cards[5];   // 手牌  
    int cardNum;   // 几张牌  
    float sum;   // 总和  
    int computer;   // 是否电脑  
    float money;   // 赌资  
    int vip;   // 是否 VIP  
} Player;   // 玩家结构体  
  
int decks[4][15] = {  
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},  
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0},  
        {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 0},  
        {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1}  
};  
  
// 牌面显示   t(ten) 10   w 小王   W 大王  
char showCards[15] = {'A', '2', '3', '4', '5', '6', '7', '8', '9',  
                      't', 'J', 'Q', 'K', 'w', 'W'};  
  
// 玩家初始化  
Player playerInit(Player player) {  
    player.sum = 0;  
    player.cardNum = 0;  
    return player;  
}  
  
  
// 快速排序 - 排玩家手牌  
void quickSortCard(Player player, int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1;  
    float x = player.cards[(l + r + 1) >> 1];  
    while (i < j) {  
        do {  
            i++;  
        } while (player.cards[i] > x);  
        do {  
            j--;  
        } while (player.cards[j] < x);  
        if (i < j) {  
            int tmp = player.cards[i];  
            player.cards[i] = player.cards[j];  
            player.cards[j] = tmp;  
        }  
    }  
    quickSortCard(player, l, i - 1);  
    quickSortCard(player, i, r);  
}  
  
  
// 快速排序 - 按牌面  
void quickSortSum(Player players[], int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1;  
    float x = players[(l + r + 1) >> 1].sum;  
    while (i < j) {  
        do {  
            i++;  
        } while (players[i].sum > x);  
        do {  
            j--;  
        } while (players[j].sum < x);  
        if (i < j) {  
            Player tmp = players[i];  
            players[i] = players[j];  
            players[j] = tmp;  
        }  
    }  
    quickSortSum(players, l, i - 1);  
    quickSortSum(players, i, r);  
}  
  
  
// 快速排序 - 按赌资  
void quickSortMoney(Player players[], int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1;  
    float x = players[(l + r + 1) >> 1].money;  
    while (i < j) {  
        do {  
            i++;  
        } while (players[i].money > x);  
        do {  
            j--;  
        } while (players[j].money < x);  
        if (i < j) {  
            Player tmp = players[i];  
            players[i] = players[j];  
            players[j] = tmp;  
        }  
    }  
    quickSortMoney(players, l, i - 1);  
    quickSortMoney(players, i, r);  
}  
  
  
// 分数计算  
float score(Deck deck, Player player) {  
    Player tmp = player;  
    quickSortCard(tmp, 0, player.cardNum - 1);  
    float tmpScore = 0;  
    for (int i = 0; i < tmp.cardNum; ++i) {  
        int card = tmp.cards[i];  
        float weight = deck.weight[i];  
        if (card > 10) {  
            tmpScore += 10 * weight;  
        } else if (card == 1) {  
            tmpScore += (tmpScore + weight * 11 > 24 ? 1.0f : 11.0f) * weight;  
        } else {  
            tmpScore += (float) card * weight;  
        }  
    }  
    return tmpScore;  
}  
  
  
// 输入玩家数组、游玩人数，得到胜利者 - 一般模式  
int getWinnerBase(Player players[], int num) {  
    quickSortSum(players, 0, num - 1);  
    for (int i = 0; i < num; ++i) {  
        if (players[i].sum <= 24) {  
            return players[i].idx;  
        }  
    }  
}  
  
  
//输入玩家数组、游玩人数，得到胜利者 - 赌注模式  
int getWinnerStake(Player players[], int num) {  
    quickSortMoney(players, 0, num - 1);  
    return players[0].idx;  
}  
  
  
// 牌库模式选择  
Deck deckModeChoose(Deck deck) {  
    int mode;   // 牌库模式  
    printf("选择牌库模式：\n0、自定义牌组模式；1、13 模式；2、4*10 模式；3、52 两小王模式；3、52 大小王模式;\n");  
    scanf("%d", &mode);  
    // 牌库放牌  
    if (mode) {  
        for (int i = 0; i < 15; ++i) {  
            deck.cards[i] = decks[deck.playMode - 1][i];  
        }  
    } else {  
        int tmp;  
        for (int i = 0; i < 15; ++i) {  
            scanf("%d", &tmp);  
            deck.cards[i] = tmp;  
        }  
    }  
  
    // 点数计算规则定义  
    printf("是否开启下列点数计算模式：0、否；1、是；\n");  
    printf("自定义牌面权重\n");  
    scanf("%d", &mode);  
    deck.scoreMode = mode;  
    if (mode) {   // 自定义权重  
        printf("是否不同牌不同权重\n");  
        scanf("%d", &mode);  
        deck.scoreMode += mode << 1;  
        if (mode) {   // 如果不同权重  
            printf("请输入 15 种牌的各自权重\n");  
            for (int i = 0; i < 15; ++i) {  
                scanf("%f", &deck.weight[i]);  
            }  
        } else {   // 如果相同权重  
            printf("请输入牌的权重\n");  
            float tmp;  
            scanf("%f", &tmp);  
            for (int i = 0; i < 15; ++i) {  
                deck.weight[i] = tmp;  
            }  
        }  
    } else {    // 不自定义  
        for (int i = 0; i < 15; ++i) {  
            deck.weight[i] = 1;  
        }  
    }  
    printf("是否 J、Q、K、王设置为 10\n");  
    scanf("%d", &mode);  
    deck.scoreMode += mode << 2;  
    printf("是否 A 设置为可视情况作 1 和 11\n");  
    scanf("%d", &mode);  
    deck.scoreMode += mode << 3;  
    return deck;  
}  
  
  
// 游玩过程 - 单次基础游玩  
int playBase(Player players[], Deck deck, int playerNum) {  
    srand(time(NULL));  
    int winner = -1;   // 胜利者  
    deck = deckModeChoose(deck);   // 牌库模式选择  
//    for (int i = 0; i < 15; ++i) {  
//        printf("%d ", deck.cards[i]);  
//    }  
    // 初始化玩家  
    for (int i = 0; i < playerNum; ++i) {  
        printf("%d 号玩家：\n", i);  
        players[i] = playerInit(players[i]);  
    }  
  
    // 正式游戏  
    while (winner < 0) {  
        int boom = 0;   // 爆牌人数  
        // 用于存放下一波剩余未爆牌玩家应该抽到的牌，配合是否 VIP 使用  
        int nextCards[playerNum];  
        for (int i = 0; i < playerNum; ++i) {   // 抽牌  
            if (players[i].sum < 24) {   // 只给未爆牌玩家抽  
                int tmp = rand() % 15;  
                deck.cards[tmp]--;  
                nextCards[i] = tmp + 1;   // 由于牌面是 1-15，而储存是 0-14，故加一  
            } else {  
                nextCards[i] = 0;  
                boom++;  
            }  
        }  
  
        if (boom < playerNum - 1) {   // 没有很多人爆牌  
            // 循环每个人  
            for (int i = 0; i < playerNum && winner < 0; ++i) {  
                int card = nextCards[i], need = 1;   // 当前抽牌 是否要牌  
  
                if (players[i].sum >= 24) {   // 爆牌直接跳过  
                    continue;  
                } else if (players[i].vip) {   // 是 VIP 看牌  
                    printf("%d 号玩家，你的下一张牌是 %c\n是否要这张牌：\n0、否；1、是\n", i, showCards[card - 1]);  
                    scanf("%d", &need);  
                }
  
                if (need) {   // 要牌  
                    printf("\n%d 号玩家得到牌 %c，", i, showCards[card - 1]);  
  
                    // 加牌  
                    players[i].cards[players[i].cardNum++] = card;  
                    players[i].sum = score(deck, players[i]);   // 求分  
                    printf("%d 号玩家目前有 %d 张牌", i, players[i].cardNum);  
  
                    // 情况判定：爆牌、自动胜利、是否开牌  
                    if (players[i].sum > 24) {  
                        printf("\n%d 号玩家爆了", i);  
                        boom++;  
                    } else if (players[i].sum == 24) {  
                        printf("\n%d 号玩家达到 24 点，自动胜利", i);  
                        winner = i;  
                    }  
                }  
  
  
            }  
        } else {   // 爆牌人数过多 未爆牌玩家直接胜利  
            for (int i = 0; i < playerNum && winner < 0; ++i) {  
                if (players[i].sum < 24) {  
                    winner = i;  
                }  
            }  
        }  
  
        // 投票表决是否开牌：所有人牌数相同且大于等于 2 开启表决 -> 大于一半人同意则开牌  
  
        printf("\n请玩家选择是否开牌\n0、否；1、是");  
        int votes = 0, tmp;   // 票数 投票人同意与否  
        for (int i = 0; i < playerNum; ++i) {  
            if (players[i].sum > 24) { continue; }   // 爆牌者跳过  
            printf("\n%d 号玩家是否同意开牌\n", i);  
            if (players[i].computer) {   // 是电脑-随机表决  
                tmp = rand() % 2;  
            } else {  
                scanf("%d", &tmp);  
            }  
            votes += tmp;  
            printf("%d 号玩家选 %d", i, tmp);  
        }  
        if (votes > (playerNum - boom) / 2) {  
            printf("\n更多人同意开牌\n");  
            winner = getWinnerBase(players, playerNum);  
        } else {  
            printf("\n更多人不同意开牌\n");  
        }  
  
  
    }  
    return winner;  
}  
  
  
// 游玩过程 - 赌注模式  
int playStake(Player players[], Deck deck, int playerNum, int freq) {  
    float stakes[playerNum];  
    while (freq--) {  
        for (int i = 0; i < playerNum; ++i) {  
            printf("请 %d 号玩家输入赌注\n", i);  
            scanf("%f", &stakes[i]);  
        }  
        int winner = playBase(players, deck, playerNum);  
        printf("\n本轮 %d 胜利\n\n", winner);  
        for (int i = 0; i < playerNum; ++i) {  
            if (i == winner) {  
                players[i].money += stakes[i] * (playerNum - 1);  
            } else {  
                players[i].money -= stakes[i];  
            }  
        }  
    }  
    return getWinnerStake(players, playerNum);  
}  
  
  
// 榜单输出  
void listOut(Player players[], Deck deck, int playerNum) {  
    printf("\n榜单如下：");  
    for (int i = 0; i < playerNum; ++i) {  
        if (deck.playMode) {  
            printf("\n玩家编号 %d 总分 %f\n持有牌面", players[i].idx, players[i].sum);  
            for (int j = 0; j < players[i].cardNum; ++j) {  
                printf("%c ", showCards[players[i].cards[j] - 1]);  
            }  
        } else {  
            printf("\n玩家编号 %d 总分 %f", players[i].idx, players[i].money);  
        }  
    }  
}  
  
  
// 主函数  
int main() {  
    int nextGame = 1;   // 是否进行下一局游戏；1-是，进行；0-否，不进行  
    while (nextGame) {  
        Deck deck;  
        int playerNum;   // 游玩人数  
  
        // 玩家定义  
        printf("输入游玩人数：\n");  
        scanf("%d", &playerNum);  
        Player players[playerNum];  
        for (int i = 0; i < playerNum; ++i) {  
            printf("%d 号玩家：\n", i);  
            players[i].idx = i;  
            players[i].money = 100;  
            printf("  该玩家是： 0、真人； 1、电脑；\n");  
            scanf("%d", &players[i].computer);  
            if (players[i].computer) {  
                players[i].vip = 0;  
            } else {  
                printf("  该玩家是否 VIP： 0、否； 1、是；\n");  
                scanf("%d", &players[i].vip);  
            }  
//            players[i] = playerInit(players[i]);  
        }  
        printf("玩家定义完成\n");  
  
        // 游玩模式选择  
        printf("选择游玩模式：\n0、赌注模式； 1、常规模式；\n");  
        scanf("%d", &deck.playMode);  
        int freq;  
        if (!deck.playMode) {  
            printf("赌注模式下游玩轮数\n");  
            scanf("%d", &freq);  
        }  
  
        // 输出榜单和胜利者  
        int winner = deck.playMode ? playBase(players, deck, playerNum) : playStake(players, deck, playerNum, freq);  
        listOut(players, deck, playerNum);  
        printf("\n%d 号玩家胜利\n\n是否开启下一局\n0、否；1、是\n", winner);  
        scanf("%d", &nextGame);  
    }  
    return 0;  
}
```

### 版本 2.0

[[#目录]]（回到目录）

> 版本目标

- 实现 UI 图形界面

> 结果

- 实现失败

> 原因

- 未找到合适的（易于配置、适用于 C、对其他环境影响小）的图形界面库
- 找到的图形库配置完成后仍有问题
	- 只适用于 C++
	- 未知环境问题

> 结论/评价/经验：对于应用开发，还是面向对象编程更合适

> 下一步行动：经由 UI 设计失败，转回 1 号版本更新


### 版本 1.2

[[#目录]]（回到目录）

> 版本功能

- 老功能

- [x] 基础游玩（抽牌、爆牌、胜利、开牌）
- [x] PVP
- [x] PVE
- [ ] 窗口/看板   `搁置` 
- [ ] UI（牌、人）   `搁置` 
- [x] 多种牌库（13 牌基础版、54 牌完全版、自定义牌库，且可通过代码直接添加）
- [x] 赌注模式（自定义次数循环赌注、非赌注正常模式）
- [x] VIP 功能
- [x] 牌特殊功能（计分权重/逻辑等）
- [x] 排名查看
- [x] 自主选择是否要牌
- [x] 电脑也可以 VIP

- 新提出功能

- [ ] 负资金淘汰
- [ ] 系统贷款
- [ ] 玩家贷款

> 存在问题

- 老问题

- [x] 玩家之间可以看到其他人的牌（人看其他人、人看电脑）
- [x] 仅 VIP 可选择要不要牌，非 VIP 不能选择，导致非 VIP 玩家达到一定点数后想不要只能想办法开牌，否则几轮后必然爆牌
- [x] 赌注不设限

- 搁置问题

- [ ] 无 UI，只能通过 Code Editor 区域输入输出

> 更新内容

- 无论何人（是否 VIP、是否真人）都可以选择是否要牌
- 电脑也可以作为 VIP 存在
- 通过清空控制台实现翻页，尽可能保证不能看见他人牌
- 显示内容补充（拿牌后看自己有什么牌和点数、赌资模式下看剩余资金）
- 代码顺序调整，尽可能保证类似/相关代码在一起
- 赌注设限，保证不为且不低于 0 以及不大于最大资金

> 版本代码

```C
//  
// Created by 86159 on 2023-06-05.  
//  
#include "stdio.h"  
#include "stdlib.h"  
#include "time.h"  
  
  
/* 牌库结构体属性  
 * playMode 游玩模式  
 * cards[15] 存各数字牌剩余数量  
 * scoreMode 计分模式  
 * // 通过二进制编码代表模式开关，0 关/否 1 开/是  
 * // 从低到高：自定义权重、不同牌不同权重、大于 10 变 10、A 可代表 1 或 11 * weight[15] 各牌权重  
 */
 typedef struct {  
    int playMode;  
    int cards[15];  
    int scoreMode;  
    float weight[15];  
} Deck;  
  
typedef struct {  
    int idx;   // 玩家编号  
    int cards[5];   // 手牌  
    int cardNum;   // 几张牌  
    float sum;   // 总和  
    int computer;   // 是否电脑  
    float money;   // 赌资  
    int vip;   // 是否 VIP 
} Player;   // 玩家结构体  
  
int decks[4][15] = {  
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},  
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0},  
        {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 0},  
        {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1}  
};  
  
// 牌面显示   t(ten) 10   w 小王   W 大王  
char cardsShow[15] = {'A', '2', '3', '4', '5', '6', '7', '8', '9',  
                      't', 'J', 'Q', 'K', 'w', 'W'};  
  
  
// 玩家初始化  
Player playerInit(Player player) {  
    player.sum = 0;  
    player.cardNum = 0;  
    return player;  
}  
  
  
// 牌库模式选择/初始化  
Deck deckModeChoose(Deck deck) {  
    int mode;   // 牌库模式  
    printf("选择牌库模式：\n0、自定义牌组模式；1、13 模式；2、4*10 模式；3、52 两小王模式；4、52 大小王模式;\n");  
    scanf("%d", &mode);  
    // 牌库放牌  
    if (mode) {  
        for (int i = 0; i < 15; ++i) {  
            deck.cards[i] = decks[deck.playMode - 1][i];  
        }  
    } else {  
        int tmp;  
        for (int i = 0; i < 15; ++i) {  
            scanf("%d", &tmp);  
            deck.cards[i] = tmp;  
        }  
    }  
  
    // 点数计算规则定义  
    printf("是否开启下列点数计算模式：0、否；1、是；\n");  
    printf("自定义牌面权重\n");  
    scanf("%d", &mode);  
    deck.scoreMode = mode;  
    if (mode) {   // 自定义权重  
        printf("是否不同牌不同权重\n");  
        scanf("%d", &mode);  
        deck.scoreMode += mode << 1;  
        if (mode) {   // 如果不同权重  
            printf("请输入 15 种牌的各自权重\n");  
            for (int i = 0; i < 15; ++i) {  
                scanf("%f", &deck.weight[i]);  
            }  
        } else {   // 如果相同权重  
            printf("请输入牌的权重\n");  
            float tmp;  
            scanf("%f", &tmp);  
            for (int i = 0; i < 15; ++i) {  
                deck.weight[i] = tmp;  
            }  
        }  
    } else {    // 不自定义  
        for (int i = 0; i < 15; ++i) {  
            deck.weight[i] = 1;  
        }  
    }  
    printf("是否 J、Q、K、王设置为 10\n");  
    scanf("%d", &mode);  
    deck.scoreMode += mode << 2;  
    printf("是否 A 设置为可视情况作 1 和 11\n");  
    scanf("%d", &mode);  
    deck.scoreMode += mode << 3;  
    return deck;  
}  
  
  
// 继续 使代码暂停，直到有任意输入时继续运行，顺便清空控制台  
void GoOn(){  
    char op[10];  
    // 翻页 2 次，第一次使上一个人进入空白页，第二次由下一个人输入，从空白页翻到他的页面，保证看不见他人牌  
    for (int i = 0; i < 2; ++i) {  
        printf("\n输入任意字符继续\n");  
        scanf("%s",op);  
        system("cls");   // 清空控制台（在这里就是直接往上翻，使其他人看不见）  
    }  
}  
  
  
// 显示玩家当前牌和总点数  
void showCards(Player player){  
    printf("\n您目前的牌有：\n");  
    for (int i = 0; i < player.cardNum; ++i) {  
        printf("%c ",cardsShow[player.cards[i]-1]);  
    }  
    printf("\n您目前的点数总和是：%f\n",player.sum);  
}  
  
  
// 显示当前所有玩家资金  
void showMoney(Player players[],int playerNum){  
    printf("\n当前各玩家资金如下：\n");  
    for (int i = 0; i < playerNum; ++i) {  
        printf("%d 号玩家：%f 分\n",i,players[i].money);  
    }  
}  
  
  
// 榜单输出  
void listOut(Player players[], Deck deck, int playerNum) {  
    printf("\n榜单如下：");  
    for (int i = 0; i < playerNum; ++i) {  
        if (deck.playMode) {  
            printf("\n玩家编号 %d 总分 %f\n持有牌面", players[i].idx, players[i].sum);  
            for (int j = 0; j < players[i].cardNum; ++j) {  
                printf("%c ", cardsShow[players[i].cards[j] - 1]);  
            }  
        } else {  
            printf("\n玩家编号 %d 总分 %f", players[i].idx, players[i].money);  
        }  
    }  
}  
  
  
// 赌资输入  
float stakeInput(Player player){  
    float stake;  
    scanf("%f", &stake);  
    while (stake<=0 || stake>player.money){  
        printf("您的赌资输入不合法，赌资应当在 0 到您的全部资金范围内，请重新输入\n");  
        scanf("%f", &stake);  
    }  
    return stake;  
}  
  
  
// 快速排序 - 排玩家手牌  
void quickSortCard(Player player, int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1, x = player.cards[(l + r + 1) >> 1];  
    while (i < j) {  
        do {  
            i++;  
        } while (player.cards[i] > x);  
        do {  
            j--;  
        } while (player.cards[j] < x);  
        if (i < j) {  
            int tmp = player.cards[i];  
            player.cards[i] = player.cards[j];  
            player.cards[j] = tmp;  
        }  
    }  
    quickSortCard(player, l, i - 1);  
    quickSortCard(player, i, r);  
}  
  
  
// 快速排序 - 按牌面  
void quickSortSum(Player players[], int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1;  
    float x = players[(l + r + 1) >> 1].sum;  
    while (i < j) {  
        do {  
            i++;  
        } while (players[i].sum > x);  
        do {  
            j--;  
        } while (players[j].sum < x);  
        if (i < j) {  
            Player tmp = players[i];  
            players[i] = players[j];  
            players[j] = tmp;  
        }  
    }  
    quickSortSum(players, l, i - 1);  
    quickSortSum(players, i, r);  
}  
  
  
// 快速排序 - 按赌资  
void quickSortMoney(Player players[], int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1;  
    float x = players[(l + r + 1) >> 1].money;  
    while (i < j) {  
        do {  
            i++;  
        } while (players[i].money > x);  
        do {  
            j--;  
        } while (players[j].money < x);  
        if (i < j) {  
            Player tmp = players[i];  
            players[i] = players[j];  
            players[j] = tmp;  
        }  
    }  
    quickSortMoney(players, l, i - 1);  
    quickSortMoney(players, i, r);  
}  
  
  
// 分数计算  
float score(Deck deck, Player player) {  
    Player tmp = player;  
    quickSortCard(tmp, 0, player.cardNum - 1);  
    float tmpScore = 0;  
    for (int i = 0; i < tmp.cardNum; ++i) {  
        int card = tmp.cards[i];  
        float weight = deck.weight[i];  
        if (card > 10) {  
            tmpScore += 10 * weight;  
        } else if (card == 1) {  
            tmpScore += (tmpScore + weight * 11 > 24 ? 1.0f : 11.0f) * weight;  
        } else {  
            tmpScore += (float) card * weight;  
        }  
    }  
    return tmpScore;  
}  
  
  
// 输入玩家数组、游玩人数，得到胜利者 - 一般模式  
int getWinnerBase(Player players[], int num) {  
    quickSortSum(players, 0, num - 1);  
    for (int i = 0; i < num; ++i) {  
        if (players[i].sum <= 24) {  
            return players[i].idx;  
        }  
    }  
}  
  
  
//输入玩家数组、游玩人数，得到胜利者 - 赌注模式  
int getWinnerStake(Player players[], int num) {  
    quickSortMoney(players, 0, num - 1);  
    return players[0].idx;  
}  
  
  
// 游玩过程 - 单次基础游玩  
int playBase(Player players[], Deck deck, int playerNum) {  
    srand(time(NULL));  
    int winner = -1;   // 胜利者  
    deck = deckModeChoose(deck);   // 牌库模式选择  
//    for (int i = 0; i < 15; ++i) {  
//        printf("%d ", deck.cards[i]);  
//    }  
    // 初始化玩家  
    for (int i = 0; i < playerNum; ++i) {  
        printf("%d 号玩家初始化完成\n", i);  
        players[i] = playerInit(players[i]);  
    }  
  
    GoOn();   // 清空控制台  
  
    // 正式游戏  
    while (winner < 0) {  
        int boom = 0;   // 爆牌人数  
        // 用于存放下一波剩余未爆牌玩家应该抽到的牌，配合是否 VIP 使用  
        int nextCards[playerNum];  
        for (int i = 0; i < playerNum; ++i) {   // 抽牌  
            if (players[i].sum < 24) {   // 只给未爆牌玩家抽  
                int tmp = rand() % 15;  
                deck.cards[tmp]--;  
                nextCards[i] = tmp + 1;   // 由于牌面是 1-15，而储存是 0-14，故加一  
            } else {  
                nextCards[i] = 0;  
                boom++;  
            }  
        }  
  
        if (boom < playerNum - 1) {   // 没有很多人爆牌  
            // 循环每个人  
            for (int i = 0; i < playerNum && winner < 0; ++i) {  
                int card = nextCards[i], need = 1;   // 当前抽牌 是否要牌  
  
                if (players[i].sum >= 24) {   // 爆牌直接跳过  
                    continue;  
                } else {  
                    // 先判定是否电脑  
                    if (players[i].computer) {  
                        // 再判定是否是 VIP                        
                        if (players[i].vip) {  
                            Player tmp = players[i];  
                            tmp.cards[tmp.cardNum++] = card;  
                            tmp.sum = score(deck, tmp);   // 求分  
                            need = tmp.sum > 24 ? 0 : 1;   // 如果加进去后爆牌则不要，否则要  
                        } else {  
                            need = rand() % 2;  
                        }  
                    } else {   // 真人  
                        if (players[i].vip) {   // 是 VIP                            
	                        printf("%d 号玩家，你的下一张牌是 %c\n", i, cardsShow[card - 1]);  
                        }  
                        printf("%d 号玩家，你是否要这张牌：\n0、否；1、是\n", i);  
                        scanf("%d", &need);  
                    }  
                }  
  
                if (need) {   // 要牌  
                    printf("\n%d 号玩家得到牌 %c，", i, cardsShow[card - 1]);  
  
                    // 加牌  
                    players[i].cards[players[i].cardNum++] = card;  
                    players[i].sum = score(deck, players[i]);   // 求分  
                    printf("%d 号玩家目前有 %d 张牌\n", i, players[i].cardNum);  
  
                    // 情况判定：爆牌、自动胜利、是否开牌  
                    if (players[i].sum > 24) {  
                        printf("\n%d 号玩家爆了", i);  
                        boom++;  
                    } else if (players[i].sum == 24) {  
                        printf("\n%d 号玩家达到 24 点，自动胜利", i);  
                        winner = i;  
                    }  
                }  
  
                showCards(players[i]);   // 显示角色卡牌和总点数  
                GoOn();   // 清空控制台  
  
            }  
        } else {   // 爆牌人数过多 未爆牌玩家直接胜利  
            for (int i = 0; i < playerNum && winner < 0; ++i) {  
                if (players[i].sum < 24) {  
                    winner = i;  
                }  
            }  
        }  
  
        // 投票表决是否开牌：所有人牌数相同且大于等于 2 开启表决 -> 大于一半人同意则开牌  
  
        printf("\n请玩家选择是否开牌\n0、否；1、是");  
        int votes = 0, tmp;   // 票数 投票人同意与否  
        for (int i = 0; i < playerNum; ++i) {  
            if (players[i].sum > 24) { continue; }   // 爆牌者跳过  
            printf("\n%d 号玩家是否同意开牌\n", i);  
            if (players[i].computer) {   // 是电脑-随机表决  
                tmp = rand() % 2;  
            } else {  
                scanf("%d", &tmp);  
            }  
            votes += tmp;  
            printf("%d 号玩家选 %d", i, tmp);  
        }  
        if (votes > (playerNum - boom) / 2) {  
            printf("\n更多人同意开牌\n");  
            winner = getWinnerBase(players, playerNum);  
        } else {  
            printf("\n更多人不同意开牌\n");  
        }  
  
        GoOn();   // 清空控制台  
  
    }  
    return winner;  
}  
  
  
// 游玩过程 - 赌注模式  
int playStake(Player players[], Deck deck, int playerNum, int freq) {  
    float stakes[playerNum];  
    while (freq--) {  
        for (int i = 0; i < playerNum; ++i) {  
            printf("请 %d 号玩家输入赌注\n", i);  
            stakes[i] = stakeInput(players[i]);  
        }  
        int winner = playBase(players, deck, playerNum);  
        printf("\n本轮 %d 胜利\n\n", winner);  
        for (int i = 0; i < playerNum; ++i) {  
            if (i == winner) {  
                players[i].money += stakes[i] * (float) (playerNum - 1);  
            } else {  
                players[i].money -= stakes[i];  
            }  
        }  
  
        showMoney(players,playerNum);   // 输出各玩家剩余资金  
        GoOn();   // 清空控制台  
  
    }  
    return getWinnerStake(players, playerNum);  
}  
  
  
// 主函数  
int main() {  
  
    int nextGame = 1;   // 是否进行下一局游戏；1-是，进行；0-否，不进行  
    while (nextGame) {  
        Deck deck;  
        int playerNum;   // 游玩人数  
  
        // 玩家定义  
        printf("输入游玩人数：\n");  
        scanf("%d", &playerNum);  
        Player players[playerNum];  
        for (int i = 0; i < playerNum; ++i) {  
            printf("%d 号玩家：\n", i);  
            players[i].idx = i;  
            players[i].money = 100;  
            printf("  该玩家是： 0、真人； 1、电脑；\n");  
            scanf("%d", &players[i].computer);  
            printf("  该玩家是否 VIP： 0、否； 1、是；\n");  
            scanf("%d", &players[i].vip);  
        }  
        printf("玩家定义完成\n");  
  
        // 游玩模式选择  
        printf("选择游玩模式：\n0、赌注模式； 1、常规模式；\n");  
        scanf("%d", &deck.playMode);  
        int freq;  
        if (!deck.playMode) {  
            printf("赌注模式下游玩轮数\n");  
            scanf("%d", &freq);  
        }  
  
        // 输出榜单和胜利者  
        int winner = deck.playMode ? playBase(players, deck, playerNum) : playStake(players, deck, playerNum, freq);  
        listOut(players, deck, playerNum);  
        printf("\n%d 号玩家胜利\n\n是否开启下一局\n0、否；1、是\n", winner);  
        scanf("%d", &nextGame);  
    }  
    return 0;  
}
```

### 版本 1.3

[[#目录]]（回到目录）

> 版本功能

- 老功能

- [x] 基础游玩（抽牌、爆牌、胜利、开牌）
- [x] PVP
- [x] PVE
- [ ] 窗口/看板   `搁置` 
- [ ] UI（牌、人）   `搁置` 
- [x] 多种牌库（13 牌基础版、54 牌完全版、自定义牌库，且可通过代码直接添加）
- [x] 赌注模式（自定义次数循环赌注、非赌注正常模式）
- [x] VIP 功能
- [x] 牌特殊功能（计分权重/逻辑等）
- [x] 排名查看
- [x] 自主选择是否要牌
- [x] 电脑也可以 VIP
- [x] 负资金淘汰
- [ ] 系统贷款
- [ ] 玩家贷款

> 存在问题

- 新问题

- [x] 平局问题
- [x] 单轮游玩得出胜利者后，由于排序方法问题，导致人员变动（排序后，假如 3 号第一名，下一轮所谓的一号玩家其实是 3 号）
- [x] 爆牌人数判定在拿牌前，应当在所有人拿完牌之后判定是否爆牌过多
- [x] 牌特殊功能实现不完全
- [x] 抽牌满了仍要牌
- [ ] 电脑抽牌后仍要人手动翻页

- 搁置问题

- [ ] 无 UI，只能通过 Code Editor 区域输入输出

> 更新内容

- 负资金者破产淘汰
- 人员顺序改变导致的编号对应错误解决
- 细微 bug 处理完成

> 版本代码

```C
//  
// Created by 86159 on 2023-06-09.  
//  
#include "stdio.h"  
#include "stdlib.h"  
#include "time.h"  
  
  
/* 牌库结构体属性  
 * playMode 游玩模式  
 * cards[15] 存各数字牌剩余数量  
 * scoreMode 计分模式  
 * // 通过二进制编码代表模式开关，0 关/否 1 开/是  
 * // 从高到低：自定义权重、不同牌不同权重、大于 10 变 10、A 可代表 1 或 11 * weight[15] 各牌权重  
 */
 typedef struct {  
    int playMode;  
    int cards[15];  
    int scoreMode;  
    float weight[15];  
} Deck;  
  
typedef struct {  
    int idx;   // 玩家编号  
    int cards[5];   // 手牌  
    int cardNum;   // 几张牌  
    float sum;   // 总和  
    int computer;   // 是否电脑   1 是 0 否  
    float money;   // 赌资  
    int vip;   // 是否是 VIP   1 是 0 否  
    int out;   // 是否被淘汰   1 是 0 否  
} Player;   // 玩家结构体  
  
int decks[4][15] = {  
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0},  
        {1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0},  
        {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 0},  
        {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1}  
};  
  
// 牌面显示   t(ten) 10   w 小王   W 大王  
char cardsShow[15] = {'A', '2', '3', '4', '5', '6', '7', '8', '9',  
                      't', 'J', 'Q', 'K', 'w', 'W'};  
  
  
// 玩家初始化  
Player playerInit(Player player) {  
    player.sum = 0;  
    player.cardNum = 0;  
    return player;  
}  
  
  
// 牌库模式选择/初始化  
Deck deckModeChoose(Deck deck) {  
    int mode;   // 牌库模式  
    printf("选择牌库模式：\n0、自定义牌组模式；1、13 模式；2、4*10 模式；3、52 两小王模式；4、52 大小王模式;\n");  
    scanf("%d", &mode);  
    // 牌库放牌  
    if (mode) {  
        for (int i = 0; i < 15; ++i) {  
            deck.cards[i] = decks[deck.playMode - 1][i];  
        }  
    } else {  
        int tmp;  
        for (int i = 0; i < 15; ++i) {  
            scanf("%d", &tmp);  
            deck.cards[i] = tmp;  
        }  
    }  
  
    // 点数计算规则定义  
    printf("是否开启下列点数计算模式：0、否；1、是；\n");  
    printf("自定义牌面权重\n");  
    scanf("%d", &mode);  
    deck.scoreMode = mode;  
    if (mode) {   // 自定义权重  
        printf("是否不同牌不同权重\n");  
        scanf("%d", &mode);  
        deck.scoreMode = (deck.scoreMode << 1) + mode;  
        if (mode) {   // 如果不同权重  
            printf("请输入 15 种牌的各自权重\n");  
            for (int i = 0; i < 15; ++i) {  
                scanf("%f", &deck.weight[i]);  
            }  
        } else {   // 如果相同权重  
            printf("请输入牌的权重\n");  
            float tmp;  
            scanf("%f", &tmp);  
            for (int i = 0; i < 15; ++i) {  
                deck.weight[i] = tmp;  
            }  
        }  
    } else {    // 不自定义  
        for (int i = 0; i < 15; ++i) {  
            deck.weight[i] = 1;  
        }  
    }  
    printf("是否 J、Q、K、王设置为 10\n");  
    scanf("%d", &mode);  
    deck.scoreMode = (deck.scoreMode << 1) + mode;  
    printf("是否 A 设置为可视情况作 1 和 11\n");  
    scanf("%d", &mode);  
    deck.scoreMode = (deck.scoreMode << 1) + mode;  
    return deck;  
}  
  
  
// 继续 使代码暂停，直到有任意输入时继续运行，顺便清空控制台  
void GoOn() {  
    char op[10];  
    // 翻页 2 次，第一次使上一个人进入空白页，第二次由下一个人输入，从空白页翻到他的页面，保证看不见他人牌  
    for (int i = 0; i < 2; ++i) {  
        printf("\n输入任意字符继续\n");  
        scanf("%s", op);  
        system("cls");   // 清空控制台（在这里就是直接往上翻，使其他人看不见）  
    }  
}  
  
  
// 显示单局所有胜利者  
void showWinnerBase(Player players[], int playerNum, int winner) {  
    // 处理平局  
    printf("\n本轮胜利的玩家有：%d 号", winner);  
    for (int i = 0; i < playerNum; ++i) {  
        int num = players[i].idx;  
        float point;  
        if (num == winner) {  
            point = players[i].sum;  
        }  
        if (num != winner && players[i].sum == point) {  
            printf("、%d 号", num);  
        }  
    }  
    printf(".\n\n");  
}  
  
  
// 显示玩家当前牌和总点数  
void showCards(Player player) {  
    printf("\n%d 号玩家\n您目前的牌有：\n", player.idx);  
    for (int i = 0; i < player.cardNum; ++i) {  
        printf("%c ", cardsShow[player.cards[i] - 1]);  
    }  
    printf("\n您目前的点数总和是：%f\n", player.sum);  
}  
  
  
// 显示当前所有玩家资金  
void showMoney(Player players[], int playerNum) {  
    printf("\n当前各玩家资金如下：\n");  
    for (int i = 0; i < playerNum; ++i) {  
        printf("%d 号玩家：%f 分\n", players[i].idx, players[i].money);  
    }  
}  
  
  
// 榜单输出  
void listOut(Player players[], Deck deck, int playerNum) {  
    printf("\n榜单如下：");  
    for (int i = 0; i < playerNum; ++i) {  
        if (deck.playMode) {  
            printf("\n玩家编号 %d 总分 %f\n持有牌面", players[i].idx, players[i].sum);  
            for (int j = 0; j < players[i].cardNum; ++j) {  
                printf("%c ", cardsShow[players[i].cards[j] - 1]);  
            }  
        } else {  
            printf("\n玩家编号 %d 总分 %f", players[i].idx, players[i].money);  
        }  
    }  
}  
  
  
// 赌资输入  
float stakeInput(Player player) {  
    float stake;  
    scanf("%f", &stake);  
    while (stake <= 0 || stake > player.money) {  
        printf("您的赌资输入不合法，赌资应当在大于零且小于等于您的全部资金，请重新输入\n您的全部资金为 %f\n",  
               player.money);  
        scanf("%f", &stake);  
    }  
    return stake;  
}  
  
  
// 快速排序 - 排玩家手牌  
void quickSortCard(Player player, int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1, x = player.cards[(l + r + 1) >> 1];  
    while (i < j) {  
        do {  
            i++;  
        } while (player.cards[i] > x);  
        do {  
            j--;  
        } while (player.cards[j] < x);  
        if (i < j) {  
            int tmp = player.cards[i];  
            player.cards[i] = player.cards[j];  
            player.cards[j] = tmp;  
        }  
    }  
    quickSortCard(player, l, i - 1);  
    quickSortCard(player, i, r);  
}  
  
  
// 快速排序 - 按牌面  
void quickSortSum(Player players[], int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1;  
    float x = players[(l + r + 1) >> 1].sum;  
    while (i < j) {  
        do {  
            i++;  
        } while (players[i].sum > x);  
        do {  
            j--;  
        } while (players[j].sum < x);  
        if (i < j) {  
            Player tmp = players[i];  
            players[i] = players[j];  
            players[j] = tmp;  
        }  
    }  
    quickSortSum(players, l, i - 1);  
    quickSortSum(players, i, r);  
}  
  
  
// 快速排序 - 按赌资  
void quickSortMoney(Player players[], int l, int r) {  
    if (l >= r) { return; }  
    int i = l - 1, j = r + 1;  
    float x = players[(l + r + 1) >> 1].money;  
    while (i < j) {  
        do {  
            i++;  
        } while (players[i].money > x);  
        do {  
            j--;  
        } while (players[j].money < x);  
        if (i < j) {  
            Player tmp = players[i];  
            players[i] = players[j];  
            players[j] = tmp;  
        }  
    }  
    quickSortMoney(players, l, i - 1);  
    quickSortMoney(players, i, r);  
}  
  
  
// 分数计算  
float score(Deck deck, Player player) {  
    Player tmp = player;  
    quickSortCard(tmp, 0, player.cardNum - 1);  
    float tmpScore = 0;  
    for (int i = 0; i < tmp.cardNum; ++i) {  
        int card = tmp.cards[i];  
        float weight = deck.weight[i];  
        if (card > 10 && ((deck.scoreMode >> 1) & 1)) {  
            tmpScore += 10 * weight;  
        } else if (card == 1 && deck.scoreMode & 1) {  
            tmpScore += (tmpScore + weight * 11 > 24 ? 1.0f : 11.0f) * weight;  
        } else {  
            tmpScore += (float) card * weight;  
        }  
    }  
    return tmpScore;  
}  
  
  
// 输入玩家数组、游玩人数，得到胜利者 - 一般模式  
int getWinnerBase(Player players[], int num) {  
    quickSortSum(players, 0, num - 1);  
    for (int i = 0; i < num; ++i) {  
        if (players[i].sum <= 24) {  
            return players[i].idx;  
        }  
    }  
}  
  
  
//输入玩家数组、游玩人数，得到胜利者 - 赌注模式  
int getWinnerStake(Player players[], int num) {  
    quickSortMoney(players, 0, num - 1);  
    return players[0].idx;  
}  
  
  
// 游玩过程 - 单次基础游玩  
int playBase(Player players[], Deck deck, int playerNum) {  
    srand(time(NULL));  
    int winner = -1;   // 胜利者  
    deck = deckModeChoose(deck);   // 牌库模式选择  
  
    GoOn();  
  
    // 初始化玩家  
    for (int i = 0; i < playerNum; ++i) {  
        printf("%d 号玩家初始化完成\n", i);  
        players[i] = playerInit(players[i]);  
    }  
  
    GoOn();   // 清空控制台  
  
    // 正式游戏  
    while (winner < 0) {  
        int boom = 0;   // 爆牌人数  
        // 用于存放下一波剩余未爆牌玩家应该抽到的牌，配合是否 VIP 使用  
        int nextCards[playerNum];  
        // 抽牌  
        for (int i = 0; i < playerNum; ++i) {  
            if (players[i].sum < 24 && !players[i].out && players[i].cardNum<5) {   // 只给未淘汰且未爆牌且未满牌玩家抽  
                int tmp = rand() % 15;  
                deck.cards[tmp]--;  
                nextCards[i] = tmp + 1;   // 由于牌面是 1-15，而储存是 0-14，故加一  
            } else {  
                nextCards[i] = 0;  
                boom++;  
            }  
        }  
  
        // 循环每个人  
        for (int i = 0; i < playerNum && winner < 0; ++i) {  
            int num = players[i].idx, card = nextCards[i], need = 1;   // 当前玩家实际编号 当前抽牌 是否要牌  
  
            if (players[i].sum >= 24 || players[i].out || players[i].cardNum<5) {   // 爆牌或淘汰或满牌直接跳过  
                continue;  
            } else {  
                // 先判定是否电脑  
                if (players[i].computer) {  
                    // 再判定是否是 VIP                    if (players[i].vip) {  
                        Player tmp = players[i];  
                        tmp.cards[tmp.cardNum++] = card;  
                        tmp.sum = score(deck, tmp);   // 求分  
                        need = tmp.sum > 24 ? 0 : 1;   // 如果加进去后爆牌则不要，否则要  
                    } else {  
                        need = rand() % 2;  
                    }  
                } else {   // 真人  
                    if (players[i].vip) {   // 是 VIP                        printf("%d 号玩家，你的下一张牌是 %c\n", num, cardsShow[card - 1]);  
                    }  
                    showCards(players[i]);  
                    printf("%d 号玩家，你是否要这张牌：\n0、否；1、是\n", num);  
                    scanf("%d", &need);  
                }  
            }  
  
            if (need) {   // 要牌  
                printf("\n%d 号玩家得到牌 %c，", num, cardsShow[card - 1]);  
  
                // 加牌  
                players[i].cards[players[i].cardNum++] = card;  
                players[i].sum = score(deck, players[i]);   // 求分  
                printf("%d 号玩家目前有 %d 张牌\n", num, players[i].cardNum);  
  
                // 情况判定：爆牌、自动胜利、是否开牌  
                if (players[i].sum > 24) {  
                    printf("\n%d 号玩家爆了", num);  
                    boom++;  
                } else if (players[i].sum == 24) {  
                    printf("\n%d 号玩家达到 24 点，自动胜利", num);  
                    winner = num;  
                }  
            } else {  
                printf("\n%d 号玩家拒绝了牌 %c", num, cardsShow[card - 1]);  
            }  
  
            showCards(players[i]);   // 显示角色卡牌和总点数  
            GoOn();   // 清空控制台  
        }  
  
        if (boom < playerNum - 1 && winner < 0) {   // 没有很多人爆牌且胜利者还未出现  
            // 投票表决是否开牌 -> 大于一半人同意则开牌  
            printf("\n请玩家选择是否开牌\n0、否；1、是");  
            int votes = 0, tmp;   // 票数 投票人同意与否  
            for (int i = 0; i < playerNum; ++i) {  
                int num = players[i].idx;  
                if (players[i].sum > 24 || players[i].out) { continue; }   // 爆牌或淘汰者跳过  
                printf("\n%d 号玩家是否同意开牌\n", num);  
                if (players[i].computer) {   // 是电脑-随机表决  
                    tmp = rand() % 2;  
                } else {  
                    scanf("%d", &tmp);  
                }  
                votes += tmp;  
                printf("%d 号玩家选 %d", num, tmp);  
            }  
            if (votes > (playerNum - boom) / 2) {  
                printf("\n更多人同意开牌\n");  
                winner = getWinnerBase(players, playerNum);  
            } else {  
                printf("\n更多人不同意开牌\n");  
            }  
  
            GoOn();   // 清空控制台  
  
        } else if (winner < 0) {   // 爆牌人数过多 未爆牌玩家直接胜利  
            for (int i = 0; i < playerNum && winner < 0; ++i) {  
                if (players[i].sum <= 24) {  
                    winner = players[i].idx;  
                }  
            }  
        }  
  
    }  
  
    return winner;  
}  
  
  
// 游玩过程 - 赌注模式 - 每轮胜利后，发牌等顺序会按牌面大小重新排列，由于爆牌人数过多或正好 24 点导致胜利不会重排游戏顺序  
int playStake(Player players[], Deck deck, int playerNum, int freq) {  
    float stakes[playerNum];  
    while (freq--) {  
        for (int i = 0; i < playerNum; ++i) {  
            int num = players[i].idx;  
            if (!players[i].out){  
                printf("请 %d 号玩家输入赌注\n", num);  
                if (players[i].computer) {  
                    stakes[num] = rand() % ((int) players[i].money);  
                    printf("%f\n",stakes[num]);  
                } else {  
                    stakes[num] = stakeInput(players[i]);  
                }  
            }  
        }  
  
        GoOn();  
  
        int winner = playBase(players, deck, playerNum);  
        showWinnerBase(players, playerNum, winner);  
        for (int i = 0; i < playerNum; ++i) {  
            int num = players[i].idx;  
            float point;  
  
            if (num == winner) {  
                players[i].money += stakes[num] * (float) (playerNum - 1);  
                point = players[i].sum;  
            }  
  
            if (num != winner && players[i].sum == point) {  
                players[i].money += stakes[num] * (float) (playerNum - 1);  
            } else {  
                players[i].money -= stakes[num];  
                players[i].out = players[i].money <= 0 ? 1 : 0;   // 资金小于等于 0 破产淘汰  
                if (players[i].out) { printf("%d 号玩家破产淘汰", num); }  
            }  
        }  
  
        GoOn();  
  
        showMoney(players, playerNum);   // 输出各玩家剩余资金  
  
        GoOn();   // 清空控制台  
  
    }  
    return getWinnerStake(players, playerNum);  
}  
  
  
// 主函数  
int main() {  
    int nextGame = 1;   // 是否进行下一局游戏；1-是，进行；0-否，不进行  
    while (nextGame) {  
        Deck deck;  
        int playerNum;   // 游玩人数  
  
        // 玩家定义  
        printf("输入游玩人数：\n");  
        scanf("%d", &playerNum);  
        Player players[playerNum];  
        for (int i = 0; i < playerNum; ++i) {  
            printf("\n%d 号玩家：\n", i);  
            players[i].out = 0;  
            players[i].idx = i;  
            players[i].money = 100;  
            printf("  该玩家是： 0、真人； 1、电脑；\n");  
            scanf("%d", &players[i].computer);  
            printf("  该玩家是否 VIP： 0、否； 1、是；\n");  
            scanf("%d", &players[i].vip);  
        }  
        printf("玩家定义完成\n");  
  
        GoOn();  
  
        // 游玩模式选择  
        printf("选择游玩模式：\n0、赌注模式； 1、常规模式；\n");  
        scanf("%d", &deck.playMode);  
        int freq;  
        if (!deck.playMode) {  
            printf("赌注模式下游玩轮数\n");  
            scanf("%d", &freq);  
        }  
  
        // 输出榜单和胜利者  
        int winner = deck.playMode ? playBase(players, deck, playerNum) : playStake(players, deck, playerNum, freq);  
        listOut(players, deck, playerNum);  
        printf("\n%d 号玩家胜利\n\n是否开启下一局\n0、否；1、是\n", winner);  
        scanf("%d", &nextGame);  
    }  
    return 0;  
}
```


### 附录

[[#目录]]（回到目录）

> 功能

- 已有功能

- [x] 基础游玩（抽牌、爆牌、胜利、开牌）
- [x] PVP
- [x] PVE
- [x] 多种牌库（13 牌基础版、54 牌完全版、自定义牌库，且可通过代码直接添加）
- [x] 赌注模式（自定义次数循环赌注、非赌注正常模式）
- [x] VIP 功能
- [x] 牌特殊功能（计分权重/逻辑等）
- [x] 排名查看
- [x] 自主选择是否要牌
- [x] 电脑也可以 VIP
- [x] 负资金淘汰

- 搁置功能

- [ ] 窗口/看板   `搁置` 
- [ ] UI（牌、人）   `搁置` 

- 新想到的或时间充裕可做功能

- [ ] 系统贷款
- [ ] 玩家贷款
- [ ] 庄家
- [ ] ……


> 存在问题

- 待定问题（考虑是否有必要解决）

- [ ] 电脑抽牌后仍要人手动翻页

- 搁置问题

- [ ] 无 UI，只能通过 Code Editor 区域输入输出
